var VAST =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n//# sourceURL=webpack://VAST/./node_modules/events/events.js?");

/***/ }),

/***/ "./src/ad.js":
/*!*******************!*\
  !*** ./src/ad.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Ad = exports.Ad = function Ad() {\n  _classCallCheck(this, Ad);\n\n  this.id = null;\n  this.sequence = null;\n  this.system = null;\n  this.title = null;\n  this.description = null;\n  this.advertiser = null;\n  this.pricing = null;\n  this.survey = null;\n  this.errorURLTemplates = [];\n  this.impressionURLTemplates = [];\n  this.creatives = [];\n  this.extensions = [];\n};\n\n//# sourceURL=webpack://VAST/./src/ad.js?");

/***/ }),

/***/ "./src/ad_extension.js":
/*!*****************************!*\
  !*** ./src/ad_extension.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AdExtension = exports.AdExtension = function AdExtension() {\n  _classCallCheck(this, AdExtension);\n\n  this.attributes = {};\n  this.children = [];\n};\n\n//# sourceURL=webpack://VAST/./src/ad_extension.js?");

/***/ }),

/***/ "./src/ad_extension_child.js":
/*!***********************************!*\
  !*** ./src/ad_extension_child.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar AdExtensionChild = exports.AdExtensionChild = function AdExtensionChild() {\n  _classCallCheck(this, AdExtensionChild);\n\n  this.name = null;\n  this.value = null;\n  this.attributes = {};\n};\n\n//# sourceURL=webpack://VAST/./src/ad_extension_child.js?");

/***/ }),

/***/ "./src/companion_ad.js":
/*!*****************************!*\
  !*** ./src/companion_ad.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CompanionAd = exports.CompanionAd = function CompanionAd() {\n  _classCallCheck(this, CompanionAd);\n\n  this.id = null;\n  this.width = 0;\n  this.height = 0;\n  this.type = null;\n  this.staticResource = null;\n  this.htmlResource = null;\n  this.iframeResource = null;\n  this.altText = null;\n  this.companionClickThroughURLTemplate = null;\n  this.companionClickTrackingURLTemplates = [];\n  this.trackingEvents = {};\n};\n\n//# sourceURL=webpack://VAST/./src/companion_ad.js?");

/***/ }),

/***/ "./src/creative/creative.js":
/*!**********************************!*\
  !*** ./src/creative/creative.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Creative = exports.Creative = function Creative() {\n  var creativeAttributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  _classCallCheck(this, Creative);\n\n  this.id = creativeAttributes.id || null;\n  this.adId = creativeAttributes.adId || null;\n  this.sequence = creativeAttributes.sequence || null;\n  this.apiFramework = creativeAttributes.apiFramework || null;\n  this.trackingEvents = {};\n};\n\n//# sourceURL=webpack://VAST/./src/creative/creative.js?");

/***/ }),

/***/ "./src/creative/creative_companion.js":
/*!********************************************!*\
  !*** ./src/creative/creative_companion.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CreativeCompanion = undefined;\n\nvar _creative = __webpack_require__(/*! ./creative */ \"./src/creative/creative.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CreativeCompanion = exports.CreativeCompanion = function (_Creative) {\n  _inherits(CreativeCompanion, _Creative);\n\n  function CreativeCompanion() {\n    var creativeAttributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, CreativeCompanion);\n\n    var _this = _possibleConstructorReturn(this, (CreativeCompanion.__proto__ || Object.getPrototypeOf(CreativeCompanion)).call(this, creativeAttributes));\n\n    _this.type = 'companion';\n    _this.variations = [];\n    return _this;\n  }\n\n  return CreativeCompanion;\n}(_creative.Creative);\n\n//# sourceURL=webpack://VAST/./src/creative/creative_companion.js?");

/***/ }),

/***/ "./src/creative/creative_linear.js":
/*!*****************************************!*\
  !*** ./src/creative/creative_linear.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CreativeLinear = undefined;\n\nvar _creative = __webpack_require__(/*! ./creative */ \"./src/creative/creative.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CreativeLinear = exports.CreativeLinear = function (_Creative) {\n  _inherits(CreativeLinear, _Creative);\n\n  function CreativeLinear() {\n    var creativeAttributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, CreativeLinear);\n\n    var _this = _possibleConstructorReturn(this, (CreativeLinear.__proto__ || Object.getPrototypeOf(CreativeLinear)).call(this, creativeAttributes));\n\n    _this.type = 'linear';\n    _this.duration = 0;\n    _this.skipDelay = null;\n    _this.mediaFiles = [];\n    _this.videoClickThroughURLTemplate = null;\n    _this.videoClickTrackingURLTemplates = [];\n    _this.videoCustomClickURLTemplates = [];\n    _this.adParameters = null;\n    _this.icons = [];\n    return _this;\n  }\n\n  return CreativeLinear;\n}(_creative.Creative);\n\n//# sourceURL=webpack://VAST/./src/creative/creative_linear.js?");

/***/ }),

/***/ "./src/creative/creative_non_linear.js":
/*!*********************************************!*\
  !*** ./src/creative/creative_non_linear.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CreativeNonLinear = undefined;\n\nvar _creative = __webpack_require__(/*! ./creative */ \"./src/creative/creative.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar CreativeNonLinear = exports.CreativeNonLinear = function (_Creative) {\n  _inherits(CreativeNonLinear, _Creative);\n\n  function CreativeNonLinear() {\n    var creativeAttributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, CreativeNonLinear);\n\n    var _this = _possibleConstructorReturn(this, (CreativeNonLinear.__proto__ || Object.getPrototypeOf(CreativeNonLinear)).call(this, creativeAttributes));\n\n    _this.type = 'nonlinear';\n    _this.variations = [];\n    return _this;\n  }\n\n  return CreativeNonLinear;\n}(_creative.Creative);\n\n//# sourceURL=webpack://VAST/./src/creative/creative_non_linear.js?");

/***/ }),

/***/ "./src/icon.js":
/*!*********************!*\
  !*** ./src/icon.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Icon = exports.Icon = function Icon() {\n  _classCallCheck(this, Icon);\n\n  this.program = null;\n  this.height = 0;\n  this.width = 0;\n  this.xPosition = 0;\n  this.yPosition = 0;\n  this.apiFramework = null;\n  this.offset = null;\n  this.duration = 0;\n  this.type = null;\n  this.staticResource = null;\n  this.htmlResource = null;\n  this.iframeResource = null;\n  this.iconClickThroughURLTemplate = null;\n  this.iconClickTrackingURLTemplates = [];\n  this.iconViewTrackingURLTemplate = null;\n};\n\n//# sourceURL=webpack://VAST/./src/icon.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VASTTracker = exports.VASTParser = exports.VASTClient = undefined;\n\nvar _vast_parser = __webpack_require__(/*! ./parser/vast_parser.js */ \"./src/parser/vast_parser.js\");\n\nvar _vast_client = __webpack_require__(/*! ./vast_client.js */ \"./src/vast_client.js\");\n\nvar _vast_tracker = __webpack_require__(/*! ./vast_tracker.js */ \"./src/vast_tracker.js\");\n\nexports.VASTClient = _vast_client.VASTClient;\nexports.VASTParser = _vast_parser.VASTParser;\nexports.VASTTracker = _vast_tracker.VASTTracker;\n\n//# sourceURL=webpack://VAST/./src/index.js?");

/***/ }),

/***/ "./src/media_file.js":
/*!***************************!*\
  !*** ./src/media_file.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MediaFile = exports.MediaFile = function MediaFile() {\n  _classCallCheck(this, MediaFile);\n\n  this.id = null;\n  this.fileURL = null;\n  this.deliveryType = 'progressive';\n  this.mimeType = null;\n  this.codec = null;\n  this.bitrate = 0;\n  this.minBitrate = 0;\n  this.maxBitrate = 0;\n  this.width = 0;\n  this.height = 0;\n  this.apiFramework = null;\n  this.scalable = null;\n  this.maintainAspectRatio = null;\n};\n\n//# sourceURL=webpack://VAST/./src/media_file.js?");

/***/ }),

/***/ "./src/non_linear_ad.js":
/*!******************************!*\
  !*** ./src/non_linear_ad.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar NonLinearAd = exports.NonLinearAd = function NonLinearAd() {\n  _classCallCheck(this, NonLinearAd);\n\n  this.id = null;\n  this.width = 0;\n  this.height = 0;\n  this.expandedWidth = 0;\n  this.expandedHeight = 0;\n  this.scalable = true;\n  this.maintainAspectRatio = true;\n  this.minSuggestedDuration = 0;\n  this.apiFramework = 'static';\n  this.type = null;\n  this.staticResource = null;\n  this.htmlResource = null;\n  this.iframeResource = null;\n  this.nonlinearClickThroughURLTemplate = null;\n  this.nonlinearClickTrackingURLTemplates = [];\n  this.adParameters = null;\n};\n\n//# sourceURL=webpack://VAST/./src/non_linear_ad.js?");

/***/ }),

/***/ "./src/parser/ad_parser.js":
/*!*********************************!*\
  !*** ./src/parser/ad_parser.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AdParser = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ad = __webpack_require__(/*! ../ad */ \"./src/ad.js\");\n\nvar _ad_extension = __webpack_require__(/*! ../ad_extension */ \"./src/ad_extension.js\");\n\nvar _ad_extension_child = __webpack_require__(/*! ../ad_extension_child */ \"./src/ad_extension_child.js\");\n\nvar _creative_companion_parser = __webpack_require__(/*! ./creative_companion_parser */ \"./src/parser/creative_companion_parser.js\");\n\nvar _creative_linear_parser = __webpack_require__(/*! ./creative_linear_parser */ \"./src/parser/creative_linear_parser.js\");\n\nvar _creative_non_linear_parser = __webpack_require__(/*! ./creative_non_linear_parser */ \"./src/parser/creative_non_linear_parser.js\");\n\nvar _parser_utils = __webpack_require__(/*! ./parser_utils */ \"./src/parser/parser_utils.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This class provides methods to parse a VAST Ad Element.\n * @export\n * @class AdParser\n */\nvar AdParser = exports.AdParser = function () {\n  /**\n   * Creates an instance of AdParser.\n   */\n  function AdParser() {\n    _classCallCheck(this, AdParser);\n\n    this.creativeCompanionParser = new _creative_companion_parser.CreativeCompanionParser();\n    this.creativeNonLinearParser = new _creative_non_linear_parser.CreativeNonLinearParser();\n    this.creativeLinearParser = new _creative_linear_parser.CreativeLinearParser();\n    this.parserUtils = new _parser_utils.ParserUtils();\n  }\n\n  /**\n   * Parses an Ad element (can either be a Wrapper or an InLine).\n   * @param  {Object} adElement - The VAST Ad element to parse.\n   * @return {Ad}\n   */\n\n\n  _createClass(AdParser, [{\n    key: 'parse',\n    value: function parse(adElement) {\n      var childNodes = adElement.childNodes;\n\n      for (var adTypeElementKey in childNodes) {\n        var adTypeElement = childNodes[adTypeElementKey];\n\n        if (!['Wrapper', 'InLine'].includes(adTypeElement.nodeName)) {\n          continue;\n        }\n\n        this.parserUtils.copyNodeAttribute('id', adElement, adTypeElement);\n        this.parserUtils.copyNodeAttribute('sequence', adElement, adTypeElement);\n\n        if (adTypeElement.nodeName === 'Wrapper') {\n          return this.parseWrapper(adTypeElement);\n        } else if (adTypeElement.nodeName === 'InLine') {\n          return this.parseInLine(adTypeElement);\n        }\n      }\n    }\n\n    /**\n     * Parses an Inline element.\n     * @param  {Object} inLineElement - The VAST Inline element to parse.\n     * @return {Ad}\n     */\n\n  }, {\n    key: 'parseInLine',\n    value: function parseInLine(inLineElement) {\n      var _this = this;\n\n      var childNodes = inLineElement.childNodes;\n      var ad = new _ad.Ad();\n      ad.id = inLineElement.getAttribute('id') || null;\n      ad.sequence = inLineElement.getAttribute('sequence') || null;\n\n      for (var nodeKey in childNodes) {\n        var node = childNodes[nodeKey];\n\n        switch (node.nodeName) {\n          case 'Error':\n            ad.errorURLTemplates.push(this.parserUtils.parseNodeText(node));\n            break;\n\n          case 'Impression':\n            ad.impressionURLTemplates.push(this.parserUtils.parseNodeText(node));\n            break;\n\n          case 'Creatives':\n            this.parserUtils.childrenByName(node, 'Creative').forEach(function (creativeElement) {\n              var creativeAttributes = {\n                id: creativeElement.getAttribute('id') || null,\n                adId: _this.parseCreativeAdIdAttribute(creativeElement),\n                sequence: creativeElement.getAttribute('sequence') || null,\n                apiFramework: creativeElement.getAttribute('apiFramework') || null\n              };\n\n              for (var creativeTypeElementKey in creativeElement.childNodes) {\n                var creativeTypeElement = creativeElement.childNodes[creativeTypeElementKey];\n\n                switch (creativeTypeElement.nodeName) {\n                  case 'Linear':\n                    var creativeLinear = _this.creativeLinearParser.parse(creativeTypeElement, creativeAttributes);\n                    if (creativeLinear) {\n                      ad.creatives.push(creativeLinear);\n                    }\n                    break;\n                  case 'NonLinearAds':\n                    var creativeNonLinear = _this.creativeNonLinearParser.parse(creativeTypeElement, creativeAttributes);\n                    if (creativeNonLinear) {\n                      ad.creatives.push(creativeNonLinear);\n                    }\n                    break;\n                  case 'CompanionAds':\n                    var creativeCompanion = _this.creativeCompanionParser.parse(creativeTypeElement, creativeAttributes);\n                    if (creativeCompanion) {\n                      ad.creatives.push(creativeCompanion);\n                    }\n                    break;\n                }\n              }\n            });\n            break;\n\n          case 'Extensions':\n            this.parseExtensions(ad.extensions, this.parserUtils.childrenByName(node, 'Extension'));\n            break;\n\n          case 'AdSystem':\n            ad.system = {\n              value: this.parserUtils.parseNodeText(node),\n              version: node.getAttribute('version') || null\n            };\n            break;\n\n          case 'AdTitle':\n            ad.title = this.parserUtils.parseNodeText(node);\n            break;\n\n          case 'Description':\n            ad.description = this.parserUtils.parseNodeText(node);\n            break;\n\n          case 'Advertiser':\n            ad.advertiser = this.parserUtils.parseNodeText(node);\n            break;\n\n          case 'Pricing':\n            ad.pricing = {\n              value: this.parserUtils.parseNodeText(node),\n              model: node.getAttribute('model') || null,\n              currency: node.getAttribute('currency') || null\n            };\n            break;\n\n          case 'Survey':\n            ad.survey = this.parserUtils.parseNodeText(node);\n            break;\n        }\n      }\n\n      return ad;\n    }\n\n    /**\n     * Parses a Wrapper element without resolving the wrapped urls.\n     * @param  {Object} wrapperElement - The VAST Wrapper element to be parsed.\n     * @return {Ad}\n     */\n\n  }, {\n    key: 'parseWrapper',\n    value: function parseWrapper(wrapperElement) {\n      var ad = this.parseInLine(wrapperElement);\n      var wrapperURLElement = this.parserUtils.childByName(wrapperElement, 'VASTAdTagURI');\n\n      if (wrapperURLElement) {\n        ad.nextWrapperURL = this.parserUtils.parseNodeText(wrapperURLElement);\n      } else {\n        wrapperURLElement = this.parserUtils.childByName(wrapperElement, 'VASTAdTagURL');\n\n        if (wrapperURLElement) {\n          ad.nextWrapperURL = this.parserUtils.parseNodeText(this.parserUtils.childByName(wrapperURLElement, 'URL'));\n        }\n      }\n\n      ad.creatives.forEach(function (wrapperCreativeElement) {\n        if (['linear', 'nonlinear'].includes(wrapperCreativeElement.type)) {\n          // TrackingEvents Linear / NonLinear\n          if (wrapperCreativeElement.trackingEvents) {\n            if (!ad.trackingEvents) {\n              ad.trackingEvents = {};\n            }\n            if (!ad.trackingEvents[wrapperCreativeElement.type]) {\n              ad.trackingEvents[wrapperCreativeElement.type] = {};\n            }\n\n            var _loop = function _loop(eventName) {\n              var urls = wrapperCreativeElement.trackingEvents[eventName];\n              if (!ad.trackingEvents[wrapperCreativeElement.type][eventName]) {\n                ad.trackingEvents[wrapperCreativeElement.type][eventName] = [];\n              }\n              urls.forEach(function (url) {\n                ad.trackingEvents[wrapperCreativeElement.type][eventName].push(url);\n              });\n            };\n\n            for (var eventName in wrapperCreativeElement.trackingEvents) {\n              _loop(eventName);\n            }\n          }\n          // ClickTracking\n          if (wrapperCreativeElement.videoClickTrackingURLTemplates) {\n            if (!ad.videoClickTrackingURLTemplates) {\n              ad.videoClickTrackingURLTemplates = [];\n            } // tmp property to save wrapper tracking URLs until they are merged\n            wrapperCreativeElement.videoClickTrackingURLTemplates.forEach(function (item) {\n              ad.videoClickTrackingURLTemplates.push(item);\n            });\n          }\n          // ClickThrough\n          if (wrapperCreativeElement.videoClickThroughURLTemplate) {\n            ad.videoClickThroughURLTemplate = wrapperCreativeElement.videoClickThroughURLTemplate;\n          }\n          // CustomClick\n          if (wrapperCreativeElement.videoCustomClickURLTemplates) {\n            if (!ad.videoCustomClickURLTemplates) {\n              ad.videoCustomClickURLTemplates = [];\n            } // tmp property to save wrapper tracking URLs until they are merged\n            wrapperCreativeElement.videoCustomClickURLTemplates.forEach(function (item) {\n              ad.videoCustomClickURLTemplates.push(item);\n            });\n          }\n        }\n      });\n\n      if (ad.nextWrapperURL) {\n        return ad;\n      }\n    }\n\n    /**\n     * Parses an array of Extension elements.\n     * @param  {Array} collection - The array used to store the parsed extensions.\n     * @param  {Array} extensions - The array of extensions to parse.\n     */\n\n  }, {\n    key: 'parseExtensions',\n    value: function parseExtensions(collection, extensions) {\n      var _this2 = this;\n\n      extensions.forEach(function (extNode) {\n        var ext = new _ad_extension.AdExtension();\n        var extNodeAttrs = extNode.attributes;\n        var childNodes = extNode.childNodes;\n\n        if (extNode.attributes) {\n          for (var extNodeAttrKey in extNodeAttrs) {\n            var extNodeAttr = extNodeAttrs[extNodeAttrKey];\n\n            if (extNodeAttr.nodeName && extNodeAttr.nodeValue) {\n              ext.attributes[extNodeAttr.nodeName] = extNodeAttr.nodeValue;\n            }\n          }\n        }\n\n        for (var childNodeKey in childNodes) {\n          var childNode = childNodes[childNodeKey];\n          var txt = _this2.parserUtils.parseNodeText(childNode);\n\n          // ignore comments / empty value\n          if (childNode.nodeName !== '#comment' && txt !== '') {\n            var extChild = new _ad_extension_child.AdExtensionChild();\n            extChild.name = childNode.nodeName;\n            extChild.value = txt;\n\n            if (childNode.attributes) {\n              var childNodeAttributes = childNode.attributes;\n\n              for (var extChildNodeAttrKey in childNodeAttributes) {\n                var extChildNodeAttr = childNodeAttributes[extChildNodeAttrKey];\n\n                extChild.attributes[extChildNodeAttr.nodeName] = extChildNodeAttr.nodeValue;\n              }\n            }\n\n            ext.children.push(extChild);\n          }\n        }\n\n        collection.push(ext);\n      });\n    }\n\n    /**\n     * Parses the creative adId Attribute.\n     * @param  {any} creativeElement - The creative element to retrieve the adId from.\n     * @return {String|null}\n     */\n\n  }, {\n    key: 'parseCreativeAdIdAttribute',\n    value: function parseCreativeAdIdAttribute(creativeElement) {\n      return creativeElement.getAttribute('AdID') || // VAST 2 spec\n      creativeElement.getAttribute('adID') || // VAST 3 spec\n      creativeElement.getAttribute('adId') || // VAST 4 spec\n      null;\n    }\n  }]);\n\n  return AdParser;\n}();\n\n//# sourceURL=webpack://VAST/./src/parser/ad_parser.js?");

/***/ }),

/***/ "./src/parser/creative_companion_parser.js":
/*!*************************************************!*\
  !*** ./src/parser/creative_companion_parser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CreativeCompanionParser = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _companion_ad = __webpack_require__(/*! ../companion_ad */ \"./src/companion_ad.js\");\n\nvar _creative_companion = __webpack_require__(/*! ../creative/creative_companion */ \"./src/creative/creative_companion.js\");\n\nvar _parser_utils = __webpack_require__(/*! ./parser_utils */ \"./src/parser/parser_utils.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This class provides methods to parse a VAST CompanionAd Element.\n * @export\n * @class CreativeCompanionParser\n */\nvar CreativeCompanionParser = exports.CreativeCompanionParser = function () {\n  /**\n   * Creates an instance of CreativeCompanionParser.\n   */\n  function CreativeCompanionParser() {\n    _classCallCheck(this, CreativeCompanionParser);\n\n    this.parserUtils = new _parser_utils.ParserUtils();\n  }\n\n  /**\n   * Parses a CompanionAd.\n   * @param  {Object} creativeElement - The VAST CompanionAd element to parse.\n   * @param  {Object} creativeAttributes - The attributes of the CompanionAd (optional).\n   * @return {CreativeCompanion}\n   */\n\n\n  _createClass(CreativeCompanionParser, [{\n    key: 'parse',\n    value: function parse(creativeElement, creativeAttributes) {\n      var _this = this;\n\n      var creative = new _creative_companion.CreativeCompanion(creativeAttributes);\n\n      this.parserUtils.childrenByName(creativeElement, 'Companion').forEach(function (companionResource) {\n        var companionAd = new _companion_ad.CompanionAd();\n        companionAd.id = companionResource.getAttribute('id') || null;\n        companionAd.width = companionResource.getAttribute('width');\n        companionAd.height = companionResource.getAttribute('height');\n        companionAd.companionClickTrackingURLTemplates = [];\n\n        _this.parserUtils.childrenByName(companionResource, 'HTMLResource').forEach(function (htmlElement) {\n          companionAd.type = htmlElement.getAttribute('creativeType') || 'text/html';\n          companionAd.htmlResource = _this.parserUtils.parseNodeText(htmlElement);\n        });\n\n        _this.parserUtils.childrenByName(companionResource, 'IFrameResource').forEach(function (iframeElement) {\n          companionAd.type = iframeElement.getAttribute('creativeType') || 0;\n          companionAd.iframeResource = _this.parserUtils.parseNodeText(iframeElement);\n        });\n\n        _this.parserUtils.childrenByName(companionResource, 'StaticResource').forEach(function (staticElement) {\n          companionAd.type = staticElement.getAttribute('creativeType') || 0;\n\n          _this.parserUtils.childrenByName(companionResource, 'AltText').forEach(function (child) {\n            companionAd.altText = _this.parserUtils.parseNodeText(child);\n          });\n\n          companionAd.staticResource = _this.parserUtils.parseNodeText(staticElement);\n        });\n\n        _this.parserUtils.childrenByName(companionResource, 'TrackingEvents').forEach(function (trackingEventsElement) {\n          _this.parserUtils.childrenByName(trackingEventsElement, 'Tracking').forEach(function (trackingElement) {\n            var eventName = trackingElement.getAttribute('event');\n            var trackingURLTemplate = _this.parserUtils.parseNodeText(trackingElement);\n            if (eventName && trackingURLTemplate) {\n              if (companionAd.trackingEvents[eventName] == null) {\n                companionAd.trackingEvents[eventName] = [];\n              }\n              companionAd.trackingEvents[eventName].push(trackingURLTemplate);\n            }\n          });\n        });\n\n        _this.parserUtils.childrenByName(companionResource, 'CompanionClickTracking').forEach(function (clickTrackingElement) {\n          companionAd.companionClickTrackingURLTemplates.push(_this.parserUtils.parseNodeText(clickTrackingElement));\n        });\n\n        companionAd.companionClickThroughURLTemplate = _this.parserUtils.parseNodeText(_this.parserUtils.childByName(companionResource, 'CompanionClickThrough'));\n        companionAd.companionClickTrackingURLTemplate = _this.parserUtils.parseNodeText(_this.parserUtils.childByName(companionResource, 'CompanionClickTracking'));\n        creative.variations.push(companionAd);\n      });\n\n      return creative;\n    }\n  }]);\n\n  return CreativeCompanionParser;\n}();\n\n//# sourceURL=webpack://VAST/./src/parser/creative_companion_parser.js?");

/***/ }),

/***/ "./src/parser/creative_linear_parser.js":
/*!**********************************************!*\
  !*** ./src/parser/creative_linear_parser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CreativeLinearParser = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _creative_linear = __webpack_require__(/*! ../creative/creative_linear */ \"./src/creative/creative_linear.js\");\n\nvar _icon = __webpack_require__(/*! ../icon */ \"./src/icon.js\");\n\nvar _media_file = __webpack_require__(/*! ../media_file */ \"./src/media_file.js\");\n\nvar _parser_utils = __webpack_require__(/*! ./parser_utils */ \"./src/parser/parser_utils.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This class provides methods to parse a VAST Linear Element.\n * @export\n * @class CreativeLinearParser\n */\nvar CreativeLinearParser = exports.CreativeLinearParser = function () {\n  /**\n   * Creates an instance of CreativeLinearParser.\n   */\n  function CreativeLinearParser() {\n    _classCallCheck(this, CreativeLinearParser);\n\n    this.parserUtils = new _parser_utils.ParserUtils();\n  }\n\n  /**\n   * Parses a Linear element.\n   * @param  {Object} creativeElement - The VAST Linear element to parse.\n   * @param  {any} creativeAttributes - The attributes of the Linear (optional).\n   * @return {CreativeLinear}\n   */\n\n\n  _createClass(CreativeLinearParser, [{\n    key: 'parse',\n    value: function parse(creativeElement, creativeAttributes) {\n      var _this = this;\n\n      var offset = void 0;\n      var creative = new _creative_linear.CreativeLinear(creativeAttributes);\n\n      creative.duration = this.parserUtils.parseDuration(this.parserUtils.parseNodeText(this.parserUtils.childByName(creativeElement, 'Duration')));\n      var skipOffset = creativeElement.getAttribute('skipoffset');\n\n      if (skipOffset == null) {\n        creative.skipDelay = null;\n      } else if (skipOffset.charAt(skipOffset.length - 1) === '%' && creative.duration !== -1) {\n        var percent = parseInt(skipOffset, 10);\n        creative.skipDelay = creative.duration * (percent / 100);\n      } else {\n        creative.skipDelay = this.parserUtils.parseDuration(skipOffset);\n      }\n\n      var videoClicksElement = this.parserUtils.childByName(creativeElement, 'VideoClicks');\n      if (videoClicksElement) {\n        creative.videoClickThroughURLTemplate = this.parserUtils.parseNodeText(this.parserUtils.childByName(videoClicksElement, 'ClickThrough'));\n\n        this.parserUtils.childrenByName(videoClicksElement, 'ClickTracking').forEach(function (clickTrackingElement) {\n          creative.videoClickTrackingURLTemplates.push(_this.parserUtils.parseNodeText(clickTrackingElement));\n        });\n\n        this.parserUtils.childrenByName(videoClicksElement, 'CustomClick').forEach(function (customClickElement) {\n          creative.videoCustomClickURLTemplates.push(_this.parserUtils.parseNodeText(customClickElement));\n        });\n      }\n\n      var adParamsElement = this.parserUtils.childByName(creativeElement, 'AdParameters');\n      if (adParamsElement) {\n        creative.adParameters = this.parserUtils.parseNodeText(adParamsElement);\n      }\n\n      this.parserUtils.childrenByName(creativeElement, 'TrackingEvents').forEach(function (trackingEventsElement) {\n        _this.parserUtils.childrenByName(trackingEventsElement, 'Tracking').forEach(function (trackingElement) {\n          var eventName = trackingElement.getAttribute('event');\n          var trackingURLTemplate = _this.parserUtils.parseNodeText(trackingElement);\n          if (eventName && trackingURLTemplate) {\n            if (eventName === 'progress') {\n              offset = trackingElement.getAttribute('offset');\n              if (!offset) {\n                return;\n              }\n              if (offset.charAt(offset.length - 1) === '%') {\n                eventName = 'progress-' + offset;\n              } else {\n                eventName = 'progress-' + Math.round(_this.parserUtils.parseDuration(offset));\n              }\n            }\n\n            if (creative.trackingEvents[eventName] == null) {\n              creative.trackingEvents[eventName] = [];\n            }\n            creative.trackingEvents[eventName].push(trackingURLTemplate);\n          }\n        });\n      });\n\n      this.parserUtils.childrenByName(creativeElement, 'MediaFiles').forEach(function (mediaFilesElement) {\n        _this.parserUtils.childrenByName(mediaFilesElement, 'MediaFile').forEach(function (mediaFileElement) {\n          var mediaFile = new _media_file.MediaFile();\n          mediaFile.id = mediaFileElement.getAttribute('id');\n          mediaFile.fileURL = _this.parserUtils.parseNodeText(mediaFileElement);\n          mediaFile.deliveryType = mediaFileElement.getAttribute('delivery');\n          mediaFile.codec = mediaFileElement.getAttribute('codec');\n          mediaFile.mimeType = mediaFileElement.getAttribute('type');\n          mediaFile.apiFramework = mediaFileElement.getAttribute('apiFramework');\n          mediaFile.bitrate = parseInt(mediaFileElement.getAttribute('bitrate') || 0);\n          mediaFile.minBitrate = parseInt(mediaFileElement.getAttribute('minBitrate') || 0);\n          mediaFile.maxBitrate = parseInt(mediaFileElement.getAttribute('maxBitrate') || 0);\n          mediaFile.width = parseInt(mediaFileElement.getAttribute('width') || 0);\n          mediaFile.height = parseInt(mediaFileElement.getAttribute('height') || 0);\n\n          var scalable = mediaFileElement.getAttribute('scalable');\n          if (scalable && typeof scalable === 'string') {\n            scalable = scalable.toLowerCase();\n            if (scalable === 'true') {\n              mediaFile.scalable = true;\n            } else if (scalable === 'false') {\n              mediaFile.scalable = false;\n            }\n          }\n\n          var maintainAspectRatio = mediaFileElement.getAttribute('maintainAspectRatio');\n          if (maintainAspectRatio && typeof maintainAspectRatio === 'string') {\n            maintainAspectRatio = maintainAspectRatio.toLowerCase();\n            if (maintainAspectRatio === 'true') {\n              mediaFile.maintainAspectRatio = true;\n            } else if (maintainAspectRatio === 'false') {\n              mediaFile.maintainAspectRatio = false;\n            }\n          }\n\n          creative.mediaFiles.push(mediaFile);\n        });\n      });\n\n      var iconsElement = this.parserUtils.childByName(creativeElement, 'Icons');\n      if (iconsElement) {\n        this.parserUtils.childrenByName(iconsElement, 'Icon').forEach(function (iconElement) {\n          var icon = new _icon.Icon();\n          icon.program = iconElement.getAttribute('program');\n          icon.height = parseInt(iconElement.getAttribute('height') || 0);\n          icon.width = parseInt(iconElement.getAttribute('width') || 0);\n          icon.xPosition = _this.parseXPosition(iconElement.getAttribute('xPosition'));\n          icon.yPosition = _this.parseYPosition(iconElement.getAttribute('yPosition'));\n          icon.apiFramework = iconElement.getAttribute('apiFramework');\n          icon.offset = _this.parserUtils.parseDuration(iconElement.getAttribute('offset'));\n          icon.duration = _this.parserUtils.parseDuration(iconElement.getAttribute('duration'));\n\n          _this.parserUtils.childrenByName(iconElement, 'HTMLResource').forEach(function (htmlElement) {\n            icon.type = htmlElement.getAttribute('creativeType') || 'text/html';\n            icon.htmlResource = _this.parserUtils.parseNodeText(htmlElement);\n          });\n\n          _this.parserUtils.childrenByName(iconElement, 'IFrameResource').forEach(function (iframeElement) {\n            icon.type = iframeElement.getAttribute('creativeType') || 0;\n            icon.iframeResource = _this.parserUtils.parseNodeText(iframeElement);\n          });\n\n          _this.parserUtils.childrenByName(iconElement, 'StaticResource').forEach(function (staticElement) {\n            icon.type = staticElement.getAttribute('creativeType') || 0;\n            icon.staticResource = _this.parserUtils.parseNodeText(staticElement);\n          });\n\n          var iconClicksElement = _this.parserUtils.childByName(iconElement, 'IconClicks');\n          if (iconClicksElement) {\n            icon.iconClickThroughURLTemplate = _this.parserUtils.parseNodeText(_this.parserUtils.childByName(iconClicksElement, 'IconClickThrough'));\n            _this.parserUtils.childrenByName(iconClicksElement, 'IconClickTracking').forEach(function (iconClickTrackingElement) {\n              icon.iconClickTrackingURLTemplates.push(_this.parserUtils.parseNodeText(iconClickTrackingElement));\n            });\n          }\n\n          icon.iconViewTrackingURLTemplate = _this.parserUtils.parseNodeText(_this.parserUtils.childByName(iconElement, 'IconViewTracking'));\n\n          creative.icons.push(icon);\n        });\n      }\n\n      return creative;\n    }\n\n    /**\n     * Parses an horizontal position into a String ('left' or 'right') or into a Number.\n     * @param  {String} xPosition - The x position to parse.\n     * @return {String|Number}\n     */\n\n  }, {\n    key: 'parseXPosition',\n    value: function parseXPosition(xPosition) {\n      if (['left', 'right'].includes(xPosition)) {\n        return xPosition;\n      }\n\n      return parseInt(xPosition || 0);\n    }\n\n    /**\n     * Parses an vertical position into a String ('top' or 'bottom') or into a Number.\n     * @param  {String} yPosition - The x position to parse.\n     * @return {String|Number}\n     */\n\n  }, {\n    key: 'parseYPosition',\n    value: function parseYPosition(yPosition) {\n      if (['top', 'bottom'].includes(yPosition)) {\n        return yPosition;\n      }\n\n      return parseInt(yPosition || 0);\n    }\n  }]);\n\n  return CreativeLinearParser;\n}();\n\n//# sourceURL=webpack://VAST/./src/parser/creative_linear_parser.js?");

/***/ }),

/***/ "./src/parser/creative_non_linear_parser.js":
/*!**************************************************!*\
  !*** ./src/parser/creative_non_linear_parser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CreativeNonLinearParser = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _creative_non_linear = __webpack_require__(/*! ../creative/creative_non_linear */ \"./src/creative/creative_non_linear.js\");\n\nvar _non_linear_ad = __webpack_require__(/*! ../non_linear_ad */ \"./src/non_linear_ad.js\");\n\nvar _parser_utils = __webpack_require__(/*! ./parser_utils */ \"./src/parser/parser_utils.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This class provides methods to parse a VAST NonLinear Element.\n * @export\n * @class CreativeNonLinearParser\n */\nvar CreativeNonLinearParser = exports.CreativeNonLinearParser = function () {\n  /**\n   * Creates an instance of CreativeNonLinearParser.\n   */\n  function CreativeNonLinearParser() {\n    _classCallCheck(this, CreativeNonLinearParser);\n\n    this.parserUtils = new _parser_utils.ParserUtils();\n  }\n\n  /**\n   * Parses a NonLinear element.\n   * @param  {any} creativeElement - The VAST NonLinear element to parse.\n   * @param  {any} creativeAttributes - The attributes of the NonLinear (optional).\n   * @return {CreativeNonLinear}\n   */\n\n\n  _createClass(CreativeNonLinearParser, [{\n    key: 'parse',\n    value: function parse(creativeElement, creativeAttributes) {\n      var _this = this;\n\n      var creative = new _creative_non_linear.CreativeNonLinear(creativeAttributes);\n\n      this.parserUtils.childrenByName(creativeElement, 'TrackingEvents').forEach(function (trackingEventsElement) {\n        var eventName = void 0,\n            trackingURLTemplate = void 0;\n        _this.parserUtils.childrenByName(trackingEventsElement, 'Tracking').forEach(function (trackingElement) {\n          eventName = trackingElement.getAttribute('event');\n          trackingURLTemplate = _this.parserUtils.parseNodeText(trackingElement);\n\n          if (eventName && trackingURLTemplate) {\n            if (creative.trackingEvents[eventName] == null) {\n              creative.trackingEvents[eventName] = [];\n            }\n            creative.trackingEvents[eventName].push(trackingURLTemplate);\n          }\n        });\n      });\n\n      this.parserUtils.childrenByName(creativeElement, 'NonLinear').forEach(function (nonlinearResource) {\n        var nonlinearAd = new _non_linear_ad.NonLinearAd();\n        nonlinearAd.id = nonlinearResource.getAttribute('id') || null;\n        nonlinearAd.width = nonlinearResource.getAttribute('width');\n        nonlinearAd.height = nonlinearResource.getAttribute('height');\n        nonlinearAd.expandedWidth = nonlinearResource.getAttribute('expandedWidth');\n        nonlinearAd.expandedHeight = nonlinearResource.getAttribute('expandedHeight');\n        nonlinearAd.scalable = _this.parserUtils.parseBoolean(nonlinearResource.getAttribute('scalable'));\n        nonlinearAd.maintainAspectRatio = _this.parserUtils.parseBoolean(nonlinearResource.getAttribute('maintainAspectRatio'));\n        nonlinearAd.minSuggestedDuration = _this.parserUtils.parseDuration(nonlinearResource.getAttribute('minSuggestedDuration'));\n        nonlinearAd.apiFramework = nonlinearResource.getAttribute('apiFramework');\n\n        _this.parserUtils.childrenByName(nonlinearResource, 'HTMLResource').forEach(function (htmlElement) {\n          nonlinearAd.type = htmlElement.getAttribute('creativeType') || 'text/html';\n          nonlinearAd.htmlResource = _this.parserUtils.parseNodeText(htmlElement);\n        });\n\n        _this.parserUtils.childrenByName(nonlinearResource, 'IFrameResource').forEach(function (iframeElement) {\n          nonlinearAd.type = iframeElement.getAttribute('creativeType') || 0;\n          nonlinearAd.iframeResource = _this.parserUtils.parseNodeText(iframeElement);\n        });\n\n        _this.parserUtils.childrenByName(nonlinearResource, 'StaticResource').forEach(function (staticElement) {\n          nonlinearAd.type = staticElement.getAttribute('creativeType') || 0;\n          nonlinearAd.staticResource = _this.parserUtils.parseNodeText(staticElement);\n        });\n\n        var adParamsElement = _this.parserUtils.childByName(nonlinearResource, 'AdParameters');\n        if (adParamsElement) {\n          nonlinearAd.adParameters = _this.parserUtils.parseNodeText(adParamsElement);\n        }\n\n        nonlinearAd.nonlinearClickThroughURLTemplate = _this.parserUtils.parseNodeText(_this.parserUtils.childByName(nonlinearResource, 'NonLinearClickThrough'));\n        _this.parserUtils.childrenByName(nonlinearResource, 'NonLinearClickTracking').forEach(function (clickTrackingElement) {\n          nonlinearAd.nonlinearClickTrackingURLTemplates.push(_this.parserUtils.parseNodeText(clickTrackingElement));\n        });\n\n        creative.variations.push(nonlinearAd);\n      });\n\n      return creative;\n    }\n  }]);\n\n  return CreativeNonLinearParser;\n}();\n\n//# sourceURL=webpack://VAST/./src/parser/creative_non_linear_parser.js?");

/***/ }),

/***/ "./src/parser/parser_utils.js":
/*!************************************!*\
  !*** ./src/parser/parser_utils.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParserUtils = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = __webpack_require__(/*! ../util/util */ \"./src/util/util.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This class provides support methods to the parsing classes.\n * @export\n * @class ParserUtils\n */\nvar ParserUtils = exports.ParserUtils = function () {\n  /**\n   * Creates an instance of ParserUtils.\n   */\n  function ParserUtils() {\n    _classCallCheck(this, ParserUtils);\n\n    this.util = new _util.Util();\n  }\n\n  /**\n   * Returns the first element of the given node which nodeName matches the given name.\n   * @param  {Object} node - The node to use to find a match.\n   * @param  {String} name - The name to look for.\n   * @return {Object}\n   */\n\n\n  _createClass(ParserUtils, [{\n    key: 'childByName',\n    value: function childByName(node, name) {\n      var childNodes = node.childNodes;\n\n      for (var childKey in childNodes) {\n        var child = childNodes[childKey];\n\n        if (child.nodeName === name) {\n          return child;\n        }\n      }\n    }\n\n    /**\n     * Returns all the elements of the given node which nodeName match the given name.\n     * @param  {any} node - The node to use to find the matches.\n     * @param  {any} name - The name to look for.\n     * @return {Array}\n     */\n\n  }, {\n    key: 'childrenByName',\n    value: function childrenByName(node, name) {\n      var children = [];\n      var childNodes = node.childNodes;\n\n      for (var childKey in childNodes) {\n        var child = childNodes[childKey];\n\n        if (child.nodeName === name) {\n          children.push(child);\n        }\n      }\n      return children;\n    }\n\n    /**\n     * Converts relative vastAdTagUri.\n     * @param  {String} vastAdTagUrl - The url to resolve.\n     * @param  {String} originalUrl - The original url.\n     * @return {String}\n     */\n\n  }, {\n    key: 'resolveVastAdTagURI',\n    value: function resolveVastAdTagURI(vastAdTagUrl, originalUrl) {\n      if (!originalUrl) {\n        return vastAdTagUrl;\n      }\n\n      if (vastAdTagUrl.indexOf('//') === 0) {\n        var _location = location,\n            protocol = _location.protocol;\n\n        return '' + protocol + vastAdTagUrl;\n      }\n\n      if (vastAdTagUrl.indexOf('://') === -1) {\n        // Resolve relative URLs (mainly for unit testing)\n        var baseURL = originalUrl.slice(0, originalUrl.lastIndexOf('/'));\n        return baseURL + '/' + vastAdTagUrl;\n      }\n\n      return vastAdTagUrl;\n    }\n\n    /**\n     * Converts a boolean string into a Boolean.\n     * @param  {String} booleanString - The boolean string to convert.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'parseBoolean',\n    value: function parseBoolean(booleanString) {\n      return ['true', 'TRUE', '1'].includes(booleanString);\n    }\n\n    /**\n     * Parses a node text (for legacy support).\n     * @param  {Object} node - The node to parse the text from.\n     * @return {String}\n     */\n\n  }, {\n    key: 'parseNodeText',\n    value: function parseNodeText(node) {\n      return node && (node.textContent || node.text || '').trim();\n    }\n\n    /**\n     * Copies an attribute from a node to another.\n     * @param  {String} attributeName - The name of the attribute to clone.\n     * @param  {Object} nodeSource - The source node to copy the attribute from.\n     * @param  {Object} nodeDestination - The destination node to copy the attribute at.\n     */\n\n  }, {\n    key: 'copyNodeAttribute',\n    value: function copyNodeAttribute(attributeName, nodeSource, nodeDestination) {\n      var attributeValue = nodeSource.getAttribute(attributeName);\n      if (attributeValue) {\n        nodeDestination.setAttribute(attributeName, attributeValue);\n      }\n    }\n\n    /**\n     * Parses a String duration into a Number.\n     * @param  {String} durationString - The dureation represented as a string.\n     * @return {Number}\n     */\n\n  }, {\n    key: 'parseDuration',\n    value: function parseDuration(durationString) {\n      if (durationString == null) {\n        return -1;\n      }\n      // Some VAST doesn't have an HH:MM:SS duration format but instead jus the number of seconds\n      if (this.util.isNumeric(durationString)) {\n        return parseInt(durationString);\n      }\n\n      var durationComponents = durationString.split(':');\n      if (durationComponents.length !== 3) {\n        return -1;\n      }\n\n      var secondsAndMS = durationComponents[2].split('.');\n      var seconds = parseInt(secondsAndMS[0]);\n      if (secondsAndMS.length === 2) {\n        seconds += parseFloat('0.' + secondsAndMS[1]);\n      }\n\n      var minutes = parseInt(durationComponents[1] * 60);\n      var hours = parseInt(durationComponents[0] * 60 * 60);\n\n      if (isNaN(hours) || isNaN(minutes) || isNaN(seconds) || minutes > 60 * 60 || seconds > 60) {\n        return -1;\n      }\n      return hours + minutes + seconds;\n    }\n\n    /**\n     * Splits an Array of ads into an Array of Arrays of ads.\n     * Each subarray contains either one ad or multiple ads (an AdPod)\n     * @param  {Array} ads - An Array of ads to split\n     * @return {Array}\n     */\n\n  }, {\n    key: 'splitVAST',\n    value: function splitVAST(ads) {\n      var splittedVAST = [];\n      var lastAdPod = null;\n\n      ads.forEach(function (ad, i) {\n        if (ad.sequence) {\n          ad.sequence = parseInt(ad.sequence, 10);\n        }\n        // The current Ad may be the next Ad of an AdPod\n        if (ad.sequence > 1) {\n          var lastAd = ads[i - 1];\n          // check if the current Ad is exactly the next one in the AdPod\n          if (lastAd && lastAd.sequence === ad.sequence - 1) {\n            lastAdPod && lastAdPod.push(ad);\n            return;\n          }\n          // If the ad had a sequence attribute but it was not part of a correctly formed\n          // AdPod, let's remove the sequence attribute\n          delete ad.sequence;\n        }\n\n        lastAdPod = [ad];\n        splittedVAST.push(lastAdPod);\n      });\n\n      return splittedVAST;\n    }\n  }]);\n\n  return ParserUtils;\n}();\n\n//# sourceURL=webpack://VAST/./src/parser/parser_utils.js?");

/***/ }),

/***/ "./src/parser/vast_parser.js":
/*!***********************************!*\
  !*** ./src/parser/vast_parser.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VASTParser = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ad_parser = __webpack_require__(/*! ./ad_parser */ \"./src/parser/ad_parser.js\");\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _parser_utils = __webpack_require__(/*! ./parser_utils */ \"./src/parser/parser_utils.js\");\n\nvar _url_handler = __webpack_require__(/*! ../url_handler */ \"./src/url_handler.js\");\n\nvar _util = __webpack_require__(/*! ../util/util */ \"./src/util/util.js\");\n\nvar _vast_response = __webpack_require__(/*! ../vast_response */ \"./src/vast_response.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar DEFAULT_MAX_WRAPPER_DEPTH = 10;\nvar DEFAULT_EVENT_DATA = {\n  ERRORCODE: 900,\n  extensions: []\n};\n\n/**\n * This class provides methods to fetch and parse a VAST document.\n * @export\n * @class VASTParser\n * @extends EventEmitter\n */\n\nvar VASTParser = exports.VASTParser = function (_EventEmitter) {\n  _inherits(VASTParser, _EventEmitter);\n\n  /**\n   * Creates an instance of VASTParser.\n   * @constructor\n   */\n  function VASTParser() {\n    _classCallCheck(this, VASTParser);\n\n    var _this = _possibleConstructorReturn(this, (VASTParser.__proto__ || Object.getPrototypeOf(VASTParser)).call(this));\n\n    _this.remainingAds = [];\n    _this.parentURLs = [];\n    _this.errorURLTemplates = [];\n    _this.rootErrorURLTemplates = [];\n    _this.maxWrapperDepth = null;\n    _this.URLTemplateFilters = [];\n    _this.fetchingOptions = {};\n\n    _this.parserUtils = new _parser_utils.ParserUtils();\n    _this.adParser = new _ad_parser.AdParser();\n    _this.util = new _util.Util();\n    return _this;\n  }\n\n  /**\n   * Adds a filter function to the array of filters which are called before fetching a VAST document.\n   * @param  {function} filter - The filter function to be added at the end of the array.\n   * @return {void}\n   */\n\n\n  _createClass(VASTParser, [{\n    key: 'addURLTemplateFilter',\n    value: function addURLTemplateFilter(filter) {\n      if (typeof filter === 'function') {\n        this.URLTemplateFilters.push(filter);\n      }\n    }\n\n    /**\n     * Removes the last element of the url templates filters array.\n     * @return {void}\n     */\n\n  }, {\n    key: 'removeURLTemplateFilter',\n    value: function removeURLTemplateFilter() {\n      this.URLTemplateFilters.pop();\n    }\n\n    /**\n     * Returns the number of filters of the url templates filters array.\n     * @return {Number}\n     */\n\n  }, {\n    key: 'countURLTemplateFilters',\n    value: function countURLTemplateFilters() {\n      return this.URLTemplateFilters.length;\n    }\n\n    /**\n     * Removes all the filter functions from the url templates filters array.\n     * @return {void}\n     */\n\n  }, {\n    key: 'clearURLTemplateFilters',\n    value: function clearURLTemplateFilters() {\n      this.URLTemplateFilters = [];\n    }\n\n    /**\n     * Tracks the error provided in the errorCode parameter and emits a VAST-error event for the given error.\n     * @param  {Array} urlTemplates - An Array of url templates to use to make the tracking call.\n     * @param  {Object} errorCode - An Object containing the error data.\n     * @param  {Object} data - One (or more) Object containing additional data.\n     * @emits  VASTParser#VAST-error\n     * @return {void}\n     */\n\n  }, {\n    key: 'trackVastError',\n    value: function trackVastError(urlTemplates, errorCode) {\n      for (var _len = arguments.length, data = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        data[_key - 2] = arguments[_key];\n      }\n\n      this.emit('VAST-error', _extends.apply(undefined, [DEFAULT_EVENT_DATA, errorCode].concat(data)));\n      this.util.track(urlTemplates, errorCode);\n    }\n\n    /**\n     * Returns an array of errorURLTemplates for the VAST being parsed.\n     * @return {Array}\n     */\n\n  }, {\n    key: 'getErrorURLTemplates',\n    value: function getErrorURLTemplates() {\n      return this.rootErrorURLTemplates.concat(this.errorURLTemplates);\n    }\n\n    /**\n     * Fetches a VAST document for the given url.\n     * Returns a Promise which resolves,rejects according to the result of the request.\n     * @param  {String} url - The url to request the VAST document.\n     * @emits  VASTParser#VAST-resolving\n     * @emits  VASTParser#VAST-resolved\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'fetchVAST',\n    value: function fetchVAST(url) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        // Process url with defined filter\n        _this2.URLTemplateFilters.forEach(function (filter) {\n          url = filter(url);\n        });\n\n        _this2.parentURLs.push(url);\n        _this2.emit('VAST-resolving', { url: url });\n\n        _this2.urlHandler.get(url, _this2.fetchingOptions, function (err, xml) {\n          _this2.emit('VAST-resolved', { url: url });\n\n          if (err) {\n            reject(err);\n          } else {\n            resolve(xml);\n          }\n        });\n      });\n    }\n\n    /**\n     * Inits the parsing properties of the class with the custom values provided as options.\n     * @param {Object} options - The options to initialize a parsing sequence\n     */\n\n  }, {\n    key: 'initParsingStatus',\n    value: function initParsingStatus() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.rootURL = '';\n      this.remainingAds = [];\n      this.parentURLs = [];\n      this.errorURLTemplates = [];\n      this.rootErrorURLTemplates = [];\n      this.maxWrapperDepth = options.wrapperLimit || DEFAULT_MAX_WRAPPER_DEPTH;\n      this.fetchingOptions = {\n        timeout: options.timeout,\n        withCredentials: options.withCredentials\n      };\n\n      this.urlHandler = options.urlhandler || new _url_handler.URLHandler();\n    }\n\n    /**\n     * Resolves the next group of ads. If all is true resolves all the remaining ads.\n     * @param  {Boolean} all - If true all the remaining ads are resolved\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'getRemainingAds',\n    value: function getRemainingAds(all) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (_this3.remainingAds.length === 0) {\n          reject(new Error('No more ads are available for the given VAST'));\n        }\n\n        var ads = all ? _this3.util.flatten(_this3.remainingAds) : _this3.remainingAds.shift();\n        _this3.errorURLTemplates = [];\n        _this3.parentURLs = [];\n\n        _this3.resolveAds(ads, { wrapperDepth: 0, originalUrl: _this3.rootURL }).then(function (resolvedAds) {\n          var response = _this3.buildVASTResponse(resolvedAds);\n\n          resolve(response);\n        }).catch(function (err) {\n          return reject(err);\n        });\n      });\n    }\n\n    /**\n     * Fetches and parses a VAST for the given url.\n     * Returns a Promise which resolves with a fully parsed VASTResponse or rejects with an Error.\n     * @param  {String} url - The url to request the VAST document.\n     * @param  {Object} options - An optional Object of parameters to be used in the parsing process.\n     * @emits  VASTParser#VAST-resolving\n     * @emits  VASTParser#VAST-resolved\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'getAndParseVAST',\n    value: function getAndParseVAST(url) {\n      var _this4 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this.initParsingStatus(options);\n      this.rootURL = url;\n\n      return new Promise(function (resolve, reject) {\n        _this4.fetchVAST(url).then(function (xml) {\n          options.originalUrl = url;\n          options.isRootVAST = true;\n\n          _this4.parse(xml, options).then(function (ads) {\n            var response = _this4.buildVASTResponse(ads);\n\n            resolve(response);\n          }).catch(function (err) {\n            return reject(err);\n          });\n        }).catch(function (err) {\n          return reject(err);\n        });\n      });\n    }\n\n    /**\n     * Parses the given xml Object into a VASTResponse.\n     * Returns a Promise which resolves with a fully parsed VASTResponse or rejects with an Error.\n     * @param  {Object} vastXml - An object representing a vast xml document.\n     * @param  {Object} options - An optional Object of parameters to be used in the parsing process.\n     * @emits  VASTParser#VAST-resolving\n     * @emits  VASTParser#VAST-resolved\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'parseVAST',\n    value: function parseVAST(vastXml) {\n      var _this5 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this.initParsingStatus(options);\n\n      return new Promise(function (resolve, reject) {\n        options.isRootVAST = true;\n\n        _this5.parse(vastXml, options).then(function (ads) {\n          var response = _this5.buildVASTResponse(ads);\n\n          resolve(response);\n        }).catch(function (err) {\n          return reject(err);\n        });\n      });\n    }\n\n    /**\n     * Builds a VASTResponse which can be returned.\n     * @param  {Array} ads - An Array of unwrapped ads\n     * @return {VASTResponse}\n     */\n\n  }, {\n    key: 'buildVASTResponse',\n    value: function buildVASTResponse(ads) {\n      var response = new _vast_response.VASTResponse();\n      response.ads = ads;\n      response.errorURLTemplates = this.getErrorURLTemplates();\n      this.completeWrapperResolving(response);\n\n      return response;\n    }\n\n    /**\n     * Parses the given xml Object into an array of ads\n     * Returns a Promise which resolves with the array or rejects with an error according to the result of the parsing.\n     * @param  {Object} vastXml - An object representing an xml document.\n     * @param  {Object} options - An optional Object of parameters to be used in the parsing process.\n     * @emits  VASTParser#VAST-resolving\n     * @emits  VASTParser#VAST-resolved\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'parse',\n    value: function parse(vastXml, _ref) {\n      var _this6 = this;\n\n      var _ref$resolveAll = _ref.resolveAll,\n          resolveAll = _ref$resolveAll === undefined ? true : _ref$resolveAll,\n          _ref$wrapperSequence = _ref.wrapperSequence,\n          wrapperSequence = _ref$wrapperSequence === undefined ? null : _ref$wrapperSequence,\n          _ref$originalUrl = _ref.originalUrl,\n          originalUrl = _ref$originalUrl === undefined ? null : _ref$originalUrl,\n          _ref$wrapperDepth = _ref.wrapperDepth,\n          wrapperDepth = _ref$wrapperDepth === undefined ? 0 : _ref$wrapperDepth,\n          _ref$isRootVAST = _ref.isRootVAST,\n          isRootVAST = _ref$isRootVAST === undefined ? false : _ref$isRootVAST;\n\n      return new Promise(function (resolve, reject) {\n        // check if is a valid VAST document\n        if (!vastXml || !vastXml.documentElement || vastXml.documentElement.nodeName !== 'VAST') {\n          reject(new Error('Invalid VAST XMLDocument'));\n        }\n\n        var ads = [];\n        var childNodes = vastXml.documentElement.childNodes;\n\n        // Fill the VASTResponse object with ads and errorURLTemplates\n        for (var nodeKey in childNodes) {\n          var node = childNodes[nodeKey];\n\n          if (node.nodeName === 'Error') {\n            var errorURLTemplate = _this6.parserUtils.parseNodeText(node);\n\n            // Distinguish root VAST url templates from ad specific ones\n            isRootVAST ? _this6.rootErrorURLTemplates.push(errorURLTemplate) : _this6.errorURLTemplates.push(errorURLTemplate);\n          }\n\n          if (node.nodeName === 'Ad') {\n            var ad = _this6.adParser.parse(node);\n\n            if (ad) {\n              ads.push(ad);\n            } else {\n              // VAST version of response not supported.\n              _this6.trackVastError(_this6.getErrorURLTemplates(), {\n                ERRORCODE: 101\n              });\n            }\n          }\n        }\n\n        var adsCount = ads.length;\n        var lastAddedAd = ads[adsCount - 1];\n        // if in child nodes we have only one ads\n        // and wrapperSequence is defined\n        // and this ads doesn't already have sequence\n        if (adsCount === 1 && wrapperSequence !== undefined && wrapperSequence !== null && lastAddedAd && !lastAddedAd.sequence) {\n          lastAddedAd.sequence = wrapperSequence;\n        }\n\n        // Split the VAST in case we don't want to resolve everything at the first time\n        if (resolveAll === false) {\n          _this6.remainingAds = _this6.parserUtils.splitVAST(ads);\n          // Remove the first element from the remaining ads array, since we're going to resolve that element\n          ads = _this6.remainingAds.shift();\n        }\n\n        _this6.resolveAds(ads, { resolveAll: resolveAll, wrapperDepth: wrapperDepth, originalUrl: originalUrl }).then(function (res) {\n          return resolve(res);\n        }).catch(function (err) {\n          return reject(err);\n        });\n      });\n    }\n\n    /**\n     * Resolves an Array of ads, recursively calling itself with the remaining ads if a no ad\n     * response is returned for the given array.\n     * @param {Array} ads - An array of ads to resolve\n     * @param {Object} options - An options Object containing resolving parameters\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'resolveAds',\n    value: function resolveAds() {\n      var _this7 = this;\n\n      var ads = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var _ref2 = arguments[1];\n      var wrapperDepth = _ref2.wrapperDepth,\n          originalUrl = _ref2.originalUrl;\n\n      return new Promise(function (resolve, reject) {\n        var resolveWrappersPromises = [];\n\n        ads.forEach(function (ad) {\n          var resolveWrappersPromise = _this7.resolveWrappers(ad, wrapperDepth, originalUrl);\n\n          resolveWrappersPromises.push(resolveWrappersPromise);\n        });\n\n        resolve(Promise.all(resolveWrappersPromises).then(function (unwrappedAds) {\n          return _this7.util.flatten(unwrappedAds);\n        }));\n      }).then(function (resolvedAds) {\n        if (!resolvedAds && _this7.remainingAds.length > 0) {\n          var _ads = _this7.remainingAds.shift();\n\n          return _this7.resolveAds(_ads, {\n            wrapperDepth: wrapperDepth,\n            originalUrl: originalUrl\n          });\n        }\n        return resolvedAds;\n      });\n    }\n\n    /**\n     * Resolves the wrappers for the given ad in a recursive way.\n     * Returns a Promise which resolves with the unwrapped ad or rejects with an error.\n     * @param  {Ad} ad - An ad to be unwrapped.\n     * @param  {Number} wrapperDepth - The reached depth in the wrapper resolving chain.\n     * @param  {String} originalUrl - The original vast url.\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'resolveWrappers',\n    value: function resolveWrappers(ad, wrapperDepth, originalUrl) {\n      var _this8 = this;\n\n      return new Promise(function (resolve, reject) {\n        // Going one level deeper in the wrapper chain\n        wrapperDepth++;\n        // We already have a resolved VAST ad, no need to resolve wrapper\n        if (!ad.nextWrapperURL) {\n          resolve(ad);\n        }\n\n        if (wrapperDepth >= _this8.maxWrapperDepth || _this8.parentURLs.includes(ad.nextWrapperURL)) {\n          // Wrapper limit reached, as defined by the video player.\n          // Too many Wrapper responses have been received with no InLine response.\n          ad.errorCode = 302;\n          delete ad.nextWrapperURL;\n          resolve(ad);\n        }\n\n        // Get full URL\n        ad.nextWrapperURL = _this8.parserUtils.resolveVastAdTagURI(ad.nextWrapperURL, originalUrl);\n\n        // sequence doesn't carry over in wrapper element\n        var wrapperSequence = ad.sequence;\n        originalUrl = ad.nextWrapperURL;\n\n        _this8.fetchVAST(ad.nextWrapperURL).then(function (xml) {\n          _this8.parse(xml, { originalUrl: originalUrl, wrapperSequence: wrapperSequence, wrapperDepth: wrapperDepth }).then(function (unwrappedAds) {\n            delete ad.nextWrapperURL;\n            if (unwrappedAds.length === 0) {\n              // No ads returned by the wrappedResponse, discard current <Ad><Wrapper> creatives\n              ad.creatives = [];\n              resolve(ad);\n            }\n\n            unwrappedAds.forEach(function (unwrappedAd) {\n              if (unwrappedAd) {\n                _this8.mergeWrapperAdData(unwrappedAd, ad);\n              }\n            });\n\n            resolve(unwrappedAds);\n          }).catch(function (err) {\n            // Timeout of VAST URI provided in Wrapper element, or of VAST URI provided in a subsequent Wrapper element.\n            // (URI was either unavailable or reached a timeout as defined by the video player.)\n            ad.errorCode = 301;\n            ad.errorMessage = err.message;\n\n            resolve(ad);\n          });\n        }).catch(function (err) {\n          return reject(err);\n        });\n      });\n    }\n\n    /**\n     * Takes care of handling errors when the wrappers are resolved.\n     * @param {VASTResponse} vastResponse - A resolved VASTResponse.\n     */\n\n  }, {\n    key: 'completeWrapperResolving',\n    value: function completeWrapperResolving(vastResponse) {\n      // We've to wait for all <Ad> elements to be parsed before handling error so we can:\n      // - Send computed extensions data\n      // - Ping all <Error> URIs defined across VAST files\n\n      // No Ad case - The parser never bump into an <Ad> element\n      if (vastResponse.ads.length === 0) {\n        this.trackVastError(vastResponse.errorURLTemplates, { ERRORCODE: 303 });\n      } else {\n        for (var index = vastResponse.ads.length - 1; index >= 0; index--) {\n          // - Error encountred while parsing\n          // - No Creative case - The parser has dealt with soma <Ad><Wrapper> or/and an <Ad><Inline> elements\n          // but no creative was found\n          var ad = vastResponse.ads[index];\n          if (ad.errorCode || ad.creatives.length === 0) {\n            this.trackVastError(ad.errorURLTemplates.concat(vastResponse.errorURLTemplates), { ERRORCODE: ad.errorCode || 303 }, { ERRORMESSAGE: ad.errorMessage || '' }, { extensions: ad.extensions }, { system: ad.system });\n            vastResponse.ads.splice(index, 1);\n          }\n        }\n      }\n    }\n\n    /**\n     * Merges the data between an unwrapped ad and his wrapper.\n     * @param  {Ad} unwrappedAd - The 'unwrapped' Ad.\n     * @param  {Ad} wrapper - The wrapper Ad.\n     * @return {void}\n     */\n\n  }, {\n    key: 'mergeWrapperAdData',\n    value: function mergeWrapperAdData(unwrappedAd, wrapper) {\n      unwrappedAd.errorURLTemplates = wrapper.errorURLTemplates.concat(unwrappedAd.errorURLTemplates);\n      unwrappedAd.impressionURLTemplates = wrapper.impressionURLTemplates.concat(unwrappedAd.impressionURLTemplates);\n      unwrappedAd.extensions = wrapper.extensions.concat(unwrappedAd.extensions);\n\n      unwrappedAd.creatives.forEach(function (creative) {\n        if (wrapper.trackingEvents && wrapper.trackingEvents[creative.type]) {\n          for (var eventName in wrapper.trackingEvents[creative.type]) {\n            var urls = wrapper.trackingEvents[creative.type][eventName];\n            if (!creative.trackingEvents[eventName]) {\n              creative.trackingEvents[eventName] = [];\n            }\n            creative.trackingEvents[eventName] = creative.trackingEvents[eventName].concat(urls);\n          }\n        }\n      });\n\n      if (wrapper.videoClickTrackingURLTemplates && wrapper.videoClickTrackingURLTemplates.length) {\n        unwrappedAd.creatives.forEach(function (creative) {\n          if (creative.type === 'linear') {\n            creative.videoClickTrackingURLTemplates = creative.videoClickTrackingURLTemplates.concat(wrapper.videoClickTrackingURLTemplates);\n          }\n        });\n      }\n\n      if (wrapper.videoCustomClickURLTemplates && wrapper.videoCustomClickURLTemplates.length) {\n        unwrappedAd.creatives.forEach(function (creative) {\n          if (creative.type === 'linear') {\n            creative.videoCustomClickURLTemplates = creative.videoCustomClickURLTemplates.concat(wrapper.videoCustomClickURLTemplates);\n          }\n        });\n      }\n\n      // VAST 2.0 support - Use Wrapper/linear/clickThrough when Inline/Linear/clickThrough is null\n      if (wrapper.videoClickThroughURLTemplate) {\n        unwrappedAd.creatives.forEach(function (creative) {\n          if (creative.type === 'linear' && creative.videoClickThroughURLTemplate == null) {\n            creative.videoClickThroughURLTemplate = wrapper.videoClickThroughURLTemplate;\n          }\n        });\n      }\n    }\n  }]);\n\n  return VASTParser;\n}(_events.EventEmitter);\n\n//# sourceURL=webpack://VAST/./src/parser/vast_parser.js?");

/***/ }),

/***/ "./src/url_handler.js":
/*!****************************!*\
  !*** ./src/url_handler.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.URLHandler = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _flash_url_handler = __webpack_require__(/*! ./urlhandlers/flash_url_handler */ \"./src/urlhandlers/flash_url_handler.js\");\n\nvar _node_url_handler = __webpack_require__(/*! ./urlhandlers/node_url_handler */ \"./src/urlhandlers/mock_node_url_handler.js\");\n\nvar _xhr_url_handler = __webpack_require__(/*! ./urlhandlers/xhr_url_handler */ \"./src/urlhandlers/xhr_url_handler.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar URLHandler = exports.URLHandler = function () {\n  function URLHandler() {\n    _classCallCheck(this, URLHandler);\n\n    this.flash = new _flash_url_handler.FlashURLHandler();\n    this.node = new _node_url_handler.NodeURLHandler();\n    this.xhr = new _xhr_url_handler.XHRURLHandler();\n  }\n\n  _createClass(URLHandler, [{\n    key: 'get',\n    value: function get(url, options, cb) {\n      // Allow skip of the options param\n      if (!cb) {\n        if (typeof options === 'function') {\n          cb = options;\n        }\n        options = {};\n      }\n\n      if (options.response) {\n        // Trick: the VAST response XML document is passed as an option\n        var _options = options,\n            response = _options.response;\n\n        delete options.response;\n        return cb(null, response);\n      } else if (options.urlhandler && options.urlhandler.supported()) {\n        // explicitly supply your own URLHandler object\n        return options.urlhandler.get(url, options, cb);\n      } else if (typeof window === 'undefined' || window === null) {\n        return this.node.get(url, options, cb);\n      } else if (this.xhr.supported()) {\n        return this.xhr.get(url, options, cb);\n      } else if (this.flash.supported()) {\n        return this.flash.get(url, options, cb);\n      } else {\n        return cb(new Error('Current context is not supported by any of the default URLHandlers. Please provide a custom URLHandler'));\n      }\n    }\n  }]);\n\n  return URLHandler;\n}();\n\n//# sourceURL=webpack://VAST/./src/url_handler.js?");

/***/ }),

/***/ "./src/urlhandlers/flash_url_handler.js":
/*!**********************************************!*\
  !*** ./src/urlhandlers/flash_url_handler.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar FlashURLHandler = exports.FlashURLHandler = function () {\n  function FlashURLHandler() {\n    _classCallCheck(this, FlashURLHandler);\n  }\n\n  _createClass(FlashURLHandler, [{\n    key: 'xdr',\n    value: function xdr() {\n      var xdr = void 0;\n      if (window.XDomainRequest) {\n        xdr = new XDomainRequest();\n      }\n      return xdr;\n    }\n  }, {\n    key: 'supported',\n    value: function supported() {\n      return !!this.xdr();\n    }\n  }, {\n    key: 'get',\n    value: function get(url, options, cb) {\n      var xmlDocument = typeof window.ActiveXObject === 'function' ? new window.ActiveXObject('Microsoft.XMLDOM') : undefined;\n\n      if (xmlDocument) {\n        xmlDocument.async = false;\n      } else {\n        return cb(new Error('FlashURLHandler: Microsoft.XMLDOM format not supported'));\n      }\n\n      var xdr = this.xdr();\n      xdr.open('GET', url);\n      xdr.timeout = options.timeout || 0;\n      xdr.withCredentials = options.withCredentials || false;\n      xdr.send();\n      xdr.onprogress = function () {};\n\n      xdr.onload = function () {\n        xmlDocument.loadXML(xdr.responseText);\n        cb(null, xmlDocument);\n      };\n    }\n  }]);\n\n  return FlashURLHandler;\n}();\n\n//# sourceURL=webpack://VAST/./src/urlhandlers/flash_url_handler.js?");

/***/ }),

/***/ "./src/urlhandlers/mock_node_url_handler.js":
/*!**************************************************!*\
  !*** ./src/urlhandlers/mock_node_url_handler.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// This mock class is loaded in stead of the original NodeURLHandler class\n// when bundling the library for browsers.\n// This allows us to avoid bundling useless node components and have a smalle build.\nvar NodeURLHandler = exports.NodeURLHandler = function () {\n  function NodeURLHandler() {\n    _classCallCheck(this, NodeURLHandler);\n  }\n\n  _createClass(NodeURLHandler, [{\n    key: 'get',\n    value: function get(url, options, cb) {\n      cb(new Error('Please bundle the library for node to use the node urlHandler'));\n    }\n  }]);\n\n  return NodeURLHandler;\n}();\n\n//# sourceURL=webpack://VAST/./src/urlhandlers/mock_node_url_handler.js?");

/***/ }),

/***/ "./src/urlhandlers/xhr_url_handler.js":
/*!********************************************!*\
  !*** ./src/urlhandlers/xhr_url_handler.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar XHRURLHandler = exports.XHRURLHandler = function () {\n  function XHRURLHandler() {\n    _classCallCheck(this, XHRURLHandler);\n  }\n\n  _createClass(XHRURLHandler, [{\n    key: 'xhr',\n    value: function xhr() {\n      var xhr = new window.XMLHttpRequest();\n      if ('withCredentials' in xhr) {\n        // check CORS support\n        return xhr;\n      }\n    }\n  }, {\n    key: 'supported',\n    value: function supported() {\n      return !!this.xhr();\n    }\n  }, {\n    key: 'get',\n    value: function get(url, options, cb) {\n      if (window.location.protocol === 'https:' && url.indexOf('http://') === 0) {\n        return cb(new Error('XHRURLHandler: Cannot go from HTTPS to HTTP.'));\n      }\n\n      try {\n        var xhr = this.xhr();\n        xhr.open('GET', url);\n        xhr.timeout = options.timeout || 0;\n        xhr.withCredentials = options.withCredentials || false;\n        xhr.overrideMimeType && xhr.overrideMimeType('text/xml');\n        xhr.onreadystatechange = function () {\n          if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n              cb(null, xhr.responseXML);\n            } else {\n              cb(new Error('XHRURLHandler: ' + xhr.statusText));\n            }\n          }\n        };\n        xhr.send();\n      } catch (error) {\n        cb(new Error('XHRURLHandler: Unexpected error'));\n      }\n    }\n  }]);\n\n  return XHRURLHandler;\n}();\n\n//# sourceURL=webpack://VAST/./src/urlhandlers/xhr_url_handler.js?");

/***/ }),

/***/ "./src/util/storage.js":
/*!*****************************!*\
  !*** ./src/util/storage.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar storage = null;\n\n/**\n * This Object represents a default storage to be used in case no other storage is available.\n * @constant\n * @type {Object}\n */\nvar DEFAULT_STORAGE = {\n  data: {},\n  length: 0,\n  getItem: function getItem(key) {\n    return this.data[key];\n  },\n  setItem: function setItem(key, value) {\n    this.data[key] = value;\n    this.length = Object.keys(this.data).length;\n  },\n  removeItem: function removeItem(key) {\n    delete data[key];\n    this.length = Object.keys(this.data).length;\n  },\n  clear: function clear() {\n    this.data = {};\n    this.length = 0;\n  }\n};\n\n/**\n * This class provides an wrapper interface to the a key-value storage.\n * It uses localStorage, sessionStorage or a custom storage if none of the two is available.\n * @export\n * @class Storage\n */\n\nvar Storage = exports.Storage = function () {\n  /**\n   * Creates an instance of Storage.\n   * @constructor\n   */\n  function Storage() {\n    _classCallCheck(this, Storage);\n\n    this.storage = this.initStorage();\n  }\n\n  /**\n   * Provides a singleton instance of the wrapped storage.\n   * @return {Object}\n   */\n\n\n  _createClass(Storage, [{\n    key: 'initStorage',\n    value: function initStorage() {\n      if (storage) {\n        return storage;\n      }\n\n      try {\n        storage = typeof window !== 'undefined' && window !== null ? window.localStorage || window.sessionStorage : null;\n      } catch (storageError) {\n        storage = null;\n      }\n\n      if (!storage || this.isStorageDisabled(storage)) {\n        storage = DEFAULT_STORAGE;\n        storage.clear();\n      }\n\n      return storage;\n    }\n\n    /**\n     * Check if storage is disabled (like in certain cases with private browsing).\n     * In Safari (Mac + iOS) when private browsing is ON, localStorage is read only\n     * http://spin.atomicobject.com/2013/01/23/ios-private-browsing-localstorage/\n     * @param {Object} storage - The storage to check.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isStorageDisabled',\n    value: function isStorageDisabled(storage) {\n      var testValue = '__VASTStorage__';\n\n      try {\n        storage.setItem(testValue, testValue);\n        if (storage.getItem(testValue) !== testValue) {\n          storage.removeItem(testValue);\n          return true;\n        }\n      } catch (e) {\n        return true;\n      }\n      storage.removeItem(testValue);\n      return false;\n    }\n\n    /**\n     * Returns the value for the given key. If the key does not exist, null is returned.\n     * @param  {String} key - The key to retrieve the value.\n     * @return {any}\n     */\n\n  }, {\n    key: 'getItem',\n    value: function getItem(key) {\n      return this.storage.getItem(key);\n    }\n\n    /**\n     * Adds or updates the value for the given key.\n     * @param  {String} key - The key to modify the value.\n     * @param  {any} value - The value to be associated with the key.\n     * @return {any}\n     */\n\n  }, {\n    key: 'setItem',\n    value: function setItem(key, value) {\n      return this.storage.setItem(key, value);\n    }\n\n    /**\n     * Removes an item for the given key.\n     * @param  {String} key - The key to remove the value.\n     * @return {any}\n     */\n\n  }, {\n    key: 'removeItem',\n    value: function removeItem(key) {\n      return this.storage.removeItem(key);\n    }\n\n    /**\n     * Removes all the items from the storage.\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      return this.storage.clear();\n    }\n  }]);\n\n  return Storage;\n}();\n\n//# sourceURL=webpack://VAST/./src/util/storage.js?");

/***/ }),

/***/ "./src/util/util.js":
/*!**************************!*\
  !*** ./src/util/util.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Util = exports.Util = function () {\n  function Util() {\n    _classCallCheck(this, Util);\n  }\n\n  _createClass(Util, [{\n    key: 'track',\n    value: function track(URLTemplates, variables) {\n      var URLs = this.resolveURLTemplates(URLTemplates, variables);\n\n      URLs.forEach(function (URL) {\n        if (typeof window !== 'undefined' && window !== null) {\n          var i = new Image();\n          i.src = URL;\n        }\n      });\n    }\n  }, {\n    key: 'resolveURLTemplates',\n    value: function resolveURLTemplates(URLTemplates) {\n      var variables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var URLs = [];\n\n      // Encode String variables, when given\n      if (variables['ASSETURI']) {\n        variables['ASSETURI'] = this.encodeURIComponentRFC3986(variables['ASSETURI']);\n      }\n      if (variables['CONTENTPLAYHEAD']) {\n        variables['CONTENTPLAYHEAD'] = this.encodeURIComponentRFC3986(variables['CONTENTPLAYHEAD']);\n      }\n\n      // Set default value for invalid ERRORCODE\n      if (variables['ERRORCODE'] && !/^[0-9]{3}$/.test(variables['ERRORCODE'])) {\n        variables['ERRORCODE'] = 900;\n      }\n\n      // Calc random/time based macros\n      variables['CACHEBUSTING'] = this.leftpad(Math.round(Math.random() * 1.0e8).toString());\n      variables['TIMESTAMP'] = this.encodeURIComponentRFC3986(new Date().toISOString());\n\n      // RANDOM/random is not defined in VAST 3/4 as a valid macro tho it's used by some adServer (Auditude)\n      variables['RANDOM'] = variables['random'] = variables['CACHEBUSTING'];\n\n      for (var URLTemplateKey in URLTemplates) {\n        var resolveURL = URLTemplates[URLTemplateKey];\n\n        if (!resolveURL) {\n          continue;\n        }\n\n        for (var key in variables) {\n          var value = variables[key];\n          var macro1 = '[' + key + ']';\n          var macro2 = '%%' + key + '%%';\n          resolveURL = resolveURL.replace(macro1, value);\n          resolveURL = resolveURL.replace(macro2, value);\n        }\n        URLs.push(resolveURL);\n      }\n\n      return URLs;\n    }\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\n\n  }, {\n    key: 'encodeURIComponentRFC3986',\n    value: function encodeURIComponentRFC3986(str) {\n      return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n        return '%' + c.charCodeAt(0).toString(16);\n      });\n    }\n  }, {\n    key: 'leftpad',\n    value: function leftpad(str) {\n      if (str.length < 8) {\n        return this.range(0, 8 - str.length, false).map(function (i) {\n          return '0';\n        }).join('') + str;\n      } else {\n        return str;\n      }\n    }\n  }, {\n    key: 'range',\n    value: function range(left, right, inclusive) {\n      var range = [];\n      var ascending = left < right;\n      var end = !inclusive ? right : ascending ? right + 1 : right - 1;\n\n      for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {\n        range.push(i);\n      }\n      return range;\n    }\n  }, {\n    key: 'isNumeric',\n    value: function isNumeric(n) {\n      return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n  }, {\n    key: 'flatten',\n    value: function flatten(arr) {\n      var _this = this;\n\n      return arr.reduce(function (flat, toFlatten) {\n        return flat.concat(Array.isArray(toFlatten) ? _this.flatten(toFlatten) : toFlatten);\n      }, []);\n    }\n  }]);\n\n  return Util;\n}();\n\n//# sourceURL=webpack://VAST/./src/util/util.js?");

/***/ }),

/***/ "./src/vast_client.js":
/*!****************************!*\
  !*** ./src/vast_client.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VASTClient = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _storage = __webpack_require__(/*! ./util/storage */ \"./src/util/storage.js\");\n\nvar _util = __webpack_require__(/*! ./util/util */ \"./src/util/util.js\");\n\nvar _vast_parser = __webpack_require__(/*! ./parser/vast_parser */ \"./src/parser/vast_parser.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * This class provides methods to fetch and parse a VAST document using VASTParser.\n * In addition it provides options to skip consecutive calls based on constraints.\n * @export\n * @class VASTClient\n */\nvar VASTClient = exports.VASTClient = function () {\n  /**\n   * Creates an instance of VASTClient.\n   * @param  {Number} cappingFreeLunch - The number of first calls to skip.\n   * @param  {Number} cappingMinimumTimeInterval - The minimum time interval between two consecutive calls.\n   * @param  {Storage} customStorage - A custom storage to use instead of the default one.\n   * @constructor\n   */\n  function VASTClient(cappingFreeLunch, cappingMinimumTimeInterval, customStorage) {\n    _classCallCheck(this, VASTClient);\n\n    this.cappingFreeLunch = cappingFreeLunch || 0;\n    this.cappingMinimumTimeInterval = cappingMinimumTimeInterval || 0;\n    this.defaultOptions = {\n      withCredentials: false,\n      timeout: 0\n    };\n    this.vastParser = new _vast_parser.VASTParser();\n    this.util = new _util.Util();\n    this.storage = customStorage || new _storage.Storage();\n\n    // Init values if not already set\n    if (this.lastSuccessfulAd === undefined) {\n      this.lastSuccessfulAd = 0;\n    }\n\n    if (this.totalCalls === undefined) {\n      this.totalCalls = 0;\n    }\n    if (this.totalCallsTimeout === undefined) {\n      this.totalCallsTimeout = 0;\n    }\n  }\n\n  _createClass(VASTClient, [{\n    key: 'getParser',\n    value: function getParser() {\n      return this.vastParser;\n    }\n  }, {\n    key: 'hasRemainingAds',\n\n\n    /**\n     * Returns a boolean indicating if there are more ads to resolve for the current parsing.\n     * @return {Boolean}\n     */\n    value: function hasRemainingAds() {\n      return this.vastParser.remainingAds.length > 0;\n    }\n\n    /**\n     * Resolves the next group of ads. If all is true resolves all the remaining ads.\n     * @param  {Boolean} all - If true all the remaining ads are resolved\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'getNextAds',\n    value: function getNextAds(all) {\n      return this.vastParser.getRemainingAds(all);\n    }\n\n    /**\n     * Gets a parsed VAST document for the given url, applying the skipping rules defined.\n     * Returns a Promise which resolves with a fully parsed VASTResponse or rejects with an Error.\n     * @param  {String} url - The url to use to fecth the VAST document.\n     * @param  {Object} options - An optional Object of parameters to be applied in the process.\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'get',\n    value: function get(url) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var now = Date.now();\n      options = _extends(this.defaultOptions, options);\n\n      // By default the client resolves only the first Ad or AdPod\n      if (!options.hasOwnProperty('resolveAll')) {\n        options.resolveAll = false;\n      }\n\n      // Check totalCallsTimeout (first call + 1 hour), if older than now,\n      // reset totalCalls number, by this way the client will be eligible again\n      // for freelunch capping\n      if (this.totalCallsTimeout < now) {\n        this.totalCalls = 1;\n        this.totalCallsTimeout = now + 60 * 60 * 1000;\n      } else {\n        this.totalCalls++;\n      }\n\n      return new Promise(function (resolve, reject) {\n        if (_this.cappingFreeLunch >= _this.totalCalls) {\n          reject(new Error('VAST call canceled \\u2013 FreeLunch capping not reached yet ' + _this.totalCalls + '/' + _this.cappingFreeLunch));\n        }\n\n        var timeSinceLastCall = now - _this.lastSuccessfulAd;\n\n        // Check timeSinceLastCall to be a positive number. If not, this mean the\n        // previous was made in the future. We reset lastSuccessfullAd value\n        if (timeSinceLastCall < 0) {\n          _this.lastSuccessfulAd = 0;\n        } else if (timeSinceLastCall < _this.cappingMinimumTimeInterval) {\n          reject(new Error('VAST call canceled \\u2013 (' + _this.cappingMinimumTimeInterval + ')ms minimum interval reached'));\n        }\n\n        _this.vastParser.getAndParseVAST(url, options).then(function (response) {\n          return resolve(response);\n        }).catch(function (err) {\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: 'lastSuccessfulAd',\n    get: function get() {\n      return this.storage.getItem('vast-client-last-successful-ad');\n    },\n    set: function set(value) {\n      this.storage.setItem('vast-client-last-successful-ad', value);\n    }\n  }, {\n    key: 'totalCalls',\n    get: function get() {\n      return this.storage.getItem('vast-client-total-calls');\n    },\n    set: function set(value) {\n      this.storage.setItem('vast-client-total-calls', value);\n    }\n  }, {\n    key: 'totalCallsTimeout',\n    get: function get() {\n      return this.storage.getItem('vast-client-total-calls-timeout');\n    },\n    set: function set(value) {\n      this.storage.setItem('vast-client-total-calls-timeout', value);\n    }\n  }]);\n\n  return VASTClient;\n}();\n\n//# sourceURL=webpack://VAST/./src/vast_client.js?");

/***/ }),

/***/ "./src/vast_response.js":
/*!******************************!*\
  !*** ./src/vast_response.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar VASTResponse = exports.VASTResponse = function VASTResponse() {\n  _classCallCheck(this, VASTResponse);\n\n  this.ads = [];\n  this.errorURLTemplates = [];\n};\n\n//# sourceURL=webpack://VAST/./src/vast_response.js?");

/***/ }),

/***/ "./src/vast_tracker.js":
/*!*****************************!*\
  !*** ./src/vast_tracker.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VASTTracker = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _companion_ad = __webpack_require__(/*! ./companion_ad */ \"./src/companion_ad.js\");\n\nvar _creative_linear = __webpack_require__(/*! ./creative/creative_linear */ \"./src/creative/creative_linear.js\");\n\nvar _events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\nvar _non_linear_ad = __webpack_require__(/*! ./non_linear_ad */ \"./src/non_linear_ad.js\");\n\nvar _util = __webpack_require__(/*! ./util/util */ \"./src/util/util.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * This class provides methods to track an ad execution.\n *\n * @export\n * @class VASTTracker\n * @extends EventEmitter\n */\nvar VASTTracker = exports.VASTTracker = function (_EventEmitter) {\n  _inherits(VASTTracker, _EventEmitter);\n\n  /**\n   * Creates an instance of VASTTracker.\n   *\n   * @param {VASTClient} client - An instance of VASTClient that can be updated by the tracker. [optional]\n   * @param {Ad} ad - The ad to track.\n   * @param {Creative} creative - The creative to track.\n   * @param {CompanionAd|NonLinearAd} [variation=null] - An optional variation of the creative.\n   * @constructor\n   */\n  function VASTTracker(client, ad, creative) {\n    var variation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, VASTTracker);\n\n    var _this = _possibleConstructorReturn(this, (VASTTracker.__proto__ || Object.getPrototypeOf(VASTTracker)).call(this));\n\n    _this.ad = ad;\n    _this.creative = creative;\n    _this.variation = variation;\n    _this.util = new _util.Util();\n    _this.muted = false;\n    _this.impressed = false;\n    _this.skippable = false;\n    _this.skipDelayDefault = -1;\n    _this.trackingEvents = {};\n    // Tracker listeners should be notified with some events\n    // no matter if there is a tracking URL or not\n    _this.emitAlwaysEvents = ['creativeView', 'start', 'firstQuartile', 'midpoint', 'thirdQuartile', 'complete', 'resume', 'pause', 'rewind', 'skip', 'closeLinear', 'close'];\n    // Have to save already triggered quartile, to not trigger again\n    _this._alreadyTriggeredQuartiles = {};\n    // Duplicate the creative's trackingEvents property so we can alter it\n    for (var eventName in _this.creative.trackingEvents) {\n      var events = _this.creative.trackingEvents[eventName];\n      _this.trackingEvents[eventName] = events.slice(0);\n    }\n    if (_this.creative instanceof _creative_linear.CreativeLinear) {\n      _this.setDuration(_this.creative.duration);\n\n      _this.skipDelay = _this.creative.skipDelay;\n      _this.linear = true;\n      _this.clickThroughURLTemplate = _this.creative.videoClickThroughURLTemplate;\n      _this.clickTrackingURLTemplates = _this.creative.videoClickTrackingURLTemplates;\n      // Nonlinear and Companion\n    } else {\n      _this.skipDelay = -1;\n      _this.linear = false;\n      // Used variation has been specified\n      if (_this.variation) {\n        if (_this.variation instanceof _non_linear_ad.NonLinearAd) {\n          _this.clickThroughURLTemplate = _this.variation.nonlinearClickThroughURLTemplate;\n          _this.clickTrackingURLTemplates = _this.variation.nonlinearClickTrackingURLTemplates;\n        } else if (_this.variation instanceof _companion_ad.CompanionAd) {\n          _this.clickThroughURLTemplate = _this.variation.companionClickThroughURLTemplate;\n          _this.clickTrackingURLTemplates = _this.variation.companionClickTrackingURLTemplates;\n        }\n      }\n    }\n\n    // If the tracker is associated with a client we add a listener to the start event\n    // to update the lastSuccessfulAd property.\n    if (client) {\n      _this.on('start', function () {\n        client.lastSuccessfullAd = Date.now();\n      });\n    }\n    return _this;\n  }\n\n  /**\n   * Sets the duration of the ad and updates the quartiles based on that.\n   *\n   * @param  {Number} duration - The duration of the ad.\n   */\n\n\n  _createClass(VASTTracker, [{\n    key: 'setDuration',\n    value: function setDuration(duration) {\n      this.assetDuration = duration;\n      // beware of key names, theses are also used as event names\n      this.quartiles = {\n        firstQuartile: Math.round(25 * this.assetDuration) / 100,\n        midpoint: Math.round(50 * this.assetDuration) / 100,\n        thirdQuartile: Math.round(75 * this.assetDuration) / 100\n      };\n    }\n\n    /**\n     * Sets the duration of the ad and updates the quartiles based on that.\n     * This is required for tracking time related events.\n     *\n     * @param {Number} progress - Current playback time in seconds.\n     * @emits VASTTracker#start\n     * @emits VASTTracker#skip-countdown\n     * @emits VASTTracker#progress-[0-100]%\n     * @emits VASTTracker#progress-[currentTime]\n     * @emits VASTTracker#rewind\n     * @emits VASTTracker#firstQuartile\n     * @emits VASTTracker#midpoint\n     * @emits VASTTracker#thirdQuartile\n     */\n\n  }, {\n    key: 'setProgress',\n    value: function setProgress(progress) {\n      var _this2 = this;\n\n      var skipDelay = this.skipDelay || this.skipDelayDefault;\n\n      if (skipDelay !== -1 && !this.skippable) {\n        if (skipDelay > progress) {\n          this.emit('skip-countdown', skipDelay - progress);\n        } else {\n          this.skippable = true;\n          this.emit('skip-countdown', 0);\n        }\n      }\n\n      if (this.linear && this.assetDuration > 0) {\n        var events = [];\n\n        if (progress > 0) {\n          var percent = Math.round(progress / this.assetDuration * 100);\n\n          events.push('start');\n          events.push('progress-' + percent + '%');\n          events.push('progress-' + Math.round(progress));\n\n          for (var quartile in this.quartiles) {\n            if (this.isQuartileReached(quartile, this.quartiles[quartile], progress)) {\n              events.push(quartile);\n              this._alreadyTriggeredQuartiles[quartile] = true;\n            }\n          }\n        }\n\n        events.forEach(function (eventName) {\n          _this2.track(eventName, true);\n        });\n\n        if (progress < this.progress) {\n          this.track('rewind');\n        }\n      }\n\n      this.progress = progress;\n    }\n\n    /**\n     * Checks if a quartile has been reached without have being triggered already.\n     *\n     * @param {String} quartile - Quartile name\n     * @param {Number} time - Time offset, when this quartile is reached in seconds.\n     * @param {Number} progress - Current progress of the ads in seconds.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isQuartileReached',\n    value: function isQuartileReached(quartile, time, progress) {\n      var quartileReached = false;\n      // if quartile time already reached and never triggered\n      if (time <= progress && !this._alreadyTriggeredQuartiles[quartile]) {\n        quartileReached = true;\n      }\n      return quartileReached;\n    }\n\n    /**\n     * Updates the mute state and calls the mute/unmute tracking URLs.\n     *\n     * @param {Boolean} muted - Indicates if the video is muted or not.\n     * @emits VASTTracker#mute\n     * @emits VASTTracker#unmute\n     */\n\n  }, {\n    key: 'setMuted',\n    value: function setMuted(muted) {\n      if (this.muted !== muted) {\n        this.track(muted ? 'mute' : 'unmute');\n      }\n      this.muted = muted;\n    }\n\n    /**\n     * Update the pause state and call the resume/pause tracking URLs.\n     *\n     * @param {Boolean} paused - Indicates if the video is paused or not.\n     * @emits VASTTracker#pause\n     * @emits VASTTracker#resume\n     */\n\n  }, {\n    key: 'setPaused',\n    value: function setPaused(paused) {\n      if (this.paused !== paused) {\n        this.track(paused ? 'pause' : 'resume');\n      }\n      this.paused = paused;\n    }\n\n    /**\n     * Updates the fullscreen state and calls the fullscreen tracking URLs.\n     *\n     * @param {Boolean} fullscreen - Indicates if the video is in fulscreen mode or not.\n     * @emits VASTTracker#fullscreen\n     * @emits VASTTracker#exitFullscreen\n     */\n\n  }, {\n    key: 'setFullscreen',\n    value: function setFullscreen(fullscreen) {\n      if (this.fullscreen !== fullscreen) {\n        this.track(fullscreen ? 'fullscreen' : 'exitFullscreen');\n      }\n      this.fullscreen = fullscreen;\n    }\n\n    /**\n     * Updates the expand state and calls the expand/collapse tracking URLs.\n     *\n     * @param {Boolean} expanded - Indicates if the video is expanded or not.\n     * @emits VASTTracker#expand\n     * @emits VASTTracker#collapse\n     */\n\n  }, {\n    key: 'setExpand',\n    value: function setExpand(expanded) {\n      if (this.expanded !== expanded) {\n        this.track(expanded ? 'expand' : 'collapse');\n      }\n      this.expanded = expanded;\n    }\n\n    /**\n     * Must be called if you want to overwrite the <Linear> Skipoffset value.\n     * This will init the skip countdown duration. Then, every time setProgress() is called,\n     * it will decrease the countdown and emit a skip-countdown event with the remaining time.\n     * Do not call this method if you want to keep the original Skipoffset value.\n     *\n     * @param {Number} duration - The time in seconds until the skip button is displayed.\n     */\n\n  }, {\n    key: 'setSkipDelay',\n    value: function setSkipDelay(duration) {\n      if (typeof duration === 'number') {\n        this.skipDelay = duration;\n      }\n    }\n\n    /**\n     * Tracks an impression (can be called only once).\n     *\n     * @emits VASTTracker#creativeView\n     */\n\n  }, {\n    key: 'trackImpression',\n    value: function trackImpression() {\n      if (!this.impressed) {\n        this.impressed = true;\n        this.trackURLs(this.ad.impressionURLTemplates);\n        this.track('creativeView');\n      }\n    }\n\n    /**\n     * Send a request to the URI provided by the VAST <Error> element.\n     * If an [ERRORCODE] macro is included, it will be substitute with errorCode.\n     *\n     * @param {String} errorCode - Replaces [ERRORCODE] macro. [ERRORCODE] values are listed in the VAST specification.\n     */\n\n  }, {\n    key: 'errorWithCode',\n    value: function errorWithCode(errorCode) {\n      this.trackURLs(this.ad.errorURLTemplates, { ERRORCODE: errorCode });\n    }\n\n    /**\n     * Must be called when the user watched the linear creative until its end.\n     * Calls the complete tracking URLs.\n     *\n     * @emits VASTTracker#complete\n     */\n\n  }, {\n    key: 'complete',\n    value: function complete() {\n      this.track('complete');\n    }\n\n    /**\n     * Must be called when the player or the window is closed during the ad.\n     * Calls the `closeLinear` (in VAST 3.0) and `close` tracking URLs.\n     *\n     * @emits VASTTracker#closeLinear\n     * @emits VASTTracker#close\n     */\n\n  }, {\n    key: 'close',\n    value: function close() {\n      this.track(this.linear ? 'closeLinear' : 'close');\n    }\n\n    /**\n     * Must be called when the skip button is clicked. Calls the skip tracking URLs.\n     *\n     * @emits VASTTracker#skip\n     */\n\n  }, {\n    key: 'skip',\n    value: function skip() {\n      this.track('skip');\n      this.trackingEvents = [];\n    }\n\n    /**\n     * Must be called when the user clicks on the creative.\n     * It calls the tracking URLs and emits a 'clickthrough' event with the resolved\n     * clickthrough URL when done.\n     *\n     * @emits VASTTracker#clickthrough\n     */\n\n  }, {\n    key: 'click',\n    value: function click() {\n      if (this.clickTrackingURLTemplates && this.clickTrackingURLTemplates.length) {\n        this.trackURLs(this.clickTrackingURLTemplates);\n      }\n\n      if (this.clickThroughURLTemplate) {\n        var variables = this.linear ? { CONTENTPLAYHEAD: this.progressFormatted() } : {};\n        var clickThroughURL = this.util.resolveURLTemplates([this.clickThroughURLTemplate], variables)[0];\n\n        this.emit('clickthrough', clickThroughURL);\n      }\n    }\n\n    /**\n     * Calls the tracking URLs for the given eventName and emits the event.\n     *\n     * @param {String} eventName - The name of the event.\n     * @param {Boolean} [once=false] - Boolean to define if the event has to be tracked only once.\n     */\n\n  }, {\n    key: 'track',\n    value: function track(eventName) {\n      var once = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // closeLinear event was introduced in VAST 3.0\n      // Fallback to vast 2.0 close event if necessary\n      if (eventName === 'closeLinear' && !this.trackingEvents[eventName] && this.trackingEvents['close']) {\n        eventName = 'close';\n      }\n\n      var trackingURLTemplates = this.trackingEvents[eventName];\n      var isAlwaysEmitEvent = this.emitAlwaysEvents.indexOf(eventName) > -1;\n\n      if (trackingURLTemplates) {\n        this.emit(eventName, '');\n        this.trackURLs(trackingURLTemplates);\n      } else if (isAlwaysEmitEvent) {\n        this.emit(eventName, '');\n      }\n\n      if (once) {\n        delete this.trackingEvents[eventName];\n        if (isAlwaysEmitEvent) {\n          this.emitAlwaysEvents.splice(this.emitAlwaysEvents.indexOf(eventName), 1);\n        }\n      }\n    }\n\n    /**\n     * Calls the tracking urls templates with the given variables.\n     *\n     * @param {Array} URLTemplates - An array of tracking url templates.\n     * @param {Object} [variables={}] - An optional Object of parameters to be used in the tracking calls.\n     */\n\n  }, {\n    key: 'trackURLs',\n    value: function trackURLs(URLTemplates) {\n      var variables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.linear) {\n        if (this.creative && this.creative.mediaFiles && this.creative.mediaFiles[0] && this.creative.mediaFiles[0].fileURL) {\n          variables['ASSETURI'] = this.creative.mediaFiles[0].fileURL;\n        }\n        variables['CONTENTPLAYHEAD'] = this.progressFormatted();\n      }\n\n      this.util.track(URLTemplates, variables);\n    }\n\n    /**\n     * Formats time progress in a readable string.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'progressFormatted',\n    value: function progressFormatted() {\n      var seconds = parseInt(this.progress);\n      var h = seconds / (60 * 60);\n      if (h.length < 2) {\n        h = '0' + h;\n      }\n      var m = seconds / 60 % 60;\n      if (m.length < 2) {\n        m = '0' + m;\n      }\n      var s = seconds % 60;\n      if (s.length < 2) {\n        s = '0' + m;\n      }\n      var ms = parseInt((this.progress - seconds) * 100);\n      return h + ':' + m + ':' + s + '.' + ms;\n    }\n  }]);\n\n  return VASTTracker;\n}(_events.EventEmitter);\n\n//# sourceURL=webpack://VAST/./src/vast_tracker.js?");

/***/ })

/******/ });